r=_=>Math.random()-.5;p=(X,Y,S,D)=>D&&(x.globalAlpha=.1,x.fillCircle(X,Y,S/2),k=_=>p(X+S*r(),Y+S*r(),S*.8,D-1),k(),k());p(999,500,500,4)
r=_=>Math.random()-.5;p=(X,Y,S,D)=>D&&(x.globalAlpha=.1,x.arc(X,Y,S/2,0,7),x.fill(),k=_=>p(X+S*r(),Y+S*r(),S*.8,D-1),k(),k());p(999,500,500,4)
r=_=>Math.random()-.5;p=(X,Y,S,D)=>{D&&(x.globalAlpha=.1,x.beginPath(),x.arc(X,Y,S/2,0,7),x.fill(),k=_=>p(X+S*r(),Y+S*r(),S*.8,D-1),k(),k())};p(999,500,500,4)
r=_=>Math.random()-.5;p=(X,Y,S,D)=>{D&&(x.globalAlpha=.1,x.beginPath(),x.arc(X,Y,S/2,0,7),x.fill(),k=_=>p(X+S*r(),Y+S*r(),S*.8,D-1),k(),k())};p(999,500,500,4)
r=_=>Math.random()-.5;p=(X,Y,S,D)=>{D&&(x.globalAlpha=.1,x.beginPath(),x.arc(X,Y,S/2,0,7),x.fill(),k=_=>p(X+S*r(),Y+S*r()/2,S*.8,D-1),k(),k())};t||p(999,500,500,4)
r=_=>Math.random()-.5;function p(X,Y,S,D,k){if(D){x.globalAlpha=.1,x.beginPath(),x.arc(X,Y,S/2,0,7),x.fill();k=_=>p(X+S*r(),Y+S*r()/2,S*.8,D-1);k();k()}};t||p(999,500,500,4)
r=_=>Math.random()-.5;p=(X,Y,S,D,k)=>{if(D){x.beginPath();x.globalAlpha=.1,x.arc(X,Y,S/2,0,7),x.fill();k=_=>p(X+S*r(),Y+S*r(),S*.8,D-1);k();k()}};p(999,500,500,4)
r=_=>Math.random()-.5;p=(X,Y,S,D,k)=>{if(D){x.beginPath(),x.globalAlpha=.1,x.arc(X,Y,S/2,0,7),x.fill();k=_=>p(X+S*r(),Y+S*r()/2,S*.8,D-1);k();k()}};t||p(999,500,500,4)
r=_=>Math.random()-.5;p=(X,Y,R,D,k)=>{if(D){x.beginPath(),x.globalAlpha=.1,x.arc(X,Y,R/2,0,7),x.fill();k=_=>{A=7*r();p(X+R*S(A),Y+R*C(A)/2,R*.8,D-1)};k();k()}};t||p(999,500,500,4)
r=_=>Math.random()-.5;p=(X,Y,R,D,k)=>{if(D){x.beginPath(),x.globalAlpha=.1,x.arc(X,Y,R/2,0,7),x.fill();k=_=>{A=7*r();p(X+R*S(A),Y+R*C(A)/2,R*.7,D-1)};k();k();k()}};t||p(999,500,500,9)
r=_=>Math.random()-.5;p=(X,Y,S,D,k)=>D&&(x.beginPath(),x.globalAlpha=.1,x.arc(X,Y,S/2,0,7),x.fill(),k=_=>p(X+2*S*r(),Y+S*r()/2,S*.8,D-1),k(),k());t||p(999,500,500,8)
// Cute and effective circles
r=_=>Math.random()-.5;p=(X,Y,S,D,k)=>D&&(x.beginPath(),x.globalAlpha=.03,x.arc(X,Y,S*.5,0,7),x.fill(),k=_=>p(X+2*S*r(),Y+S*r()/2,S*.8,D-1),k(),k());t||p(999,500,500,14)
// Looks nice at depth 20
r=_=>Math.random()-.5;p=(X,Y,S,D,k)=>D&&(x.beginPath(),x.globalAlpha=.01,x.arc(X,Y,S*.5,0,7),x.fill(),k=_=>p(X+2*S*r(),Y+S*r()/2,S*.8,D-1),k(),k());t||p(999,500,500,16)
// SWitching to rectangles to reduce character
r=_=>Math.random()-.5;p=(X,Y,S,D,k)=>D&&(x.globalAlpha=.01,x.fillRect(X,Y,S,S),k=_=>p(X+2*S*r(),Y+S*r()/2,S*.8,D-1),k(),k());t||p(999,500,500,15)
r=_=>Math.random()-.5;p=(X,Y,S,D,k)=>D&&(x.globalAlpha=.01,x.fillRect(X,Y,S,S),k=_=>p(X+2*S*r(),Y+S*r()/2,S*.8,D-1),k(),k());t||p(999,500,500,15)
r=_=>Math.random()-.5;p=(X,Y,S,D,k)=>D&&(x.globalAlpha=.01,x.fillRect(X,Y,S,S),k=_=>p(X+2*S*r(),Y+S*r()/2,S*.8,D-1),k(),k());t||p(999,500,500,15)
r=n=>n*Math.random();p=(X,Y,S,D,k)=>D&&(x.globalAlpha=.01,x.fillRect(X,Y,S,S),k=_=>p(X+r(2*S)-S,Y+r(S/2),S*.8,D-1),k(),k());t||p(900,0,500,15)
// --- Release? ---
r=Math.random;p=(X,Y,S,D,k)=>D&&(x.globalAlpha=.01,x.fillRect(X,Y,S,S),k=_=>p(X+2*S*r()-S,Y+S*r()/2,S*.8,D-1),k(),k());t||p(900,0,500,18)
// or?
r=Math.random;p=(X,Y,S,D,k)=>D&&(x.globalAlpha=.01,x.fillRect(X,Y,S,S*.7),k=_=>p(X+2*S*r()-S,Y+S*r()/2,S*.8,D-1),k(),k());t||p(900,0,500,18)
// or?
r=Math.random;p=(X,Y,S,D,k)=>D&&(x.globalAlpha=.01,x.fillRect(X,Y,S,S),k=f=>p(X+2*S*r()-S,Y+S*r()/f,S*.8,D-1),k(2),k(3));t||p(900,0,500,18)
// Animated
r=Math.random;p=(X,Y,S,D,k)=>D&&(x.globalAlpha=.01,x.fillRect(X,Y,S,S),k=_=>p(X+2*S*r()-S,Y+S*r()/2,S*.8,D-1),k(),k());c.width|=0;p(900,0,500,15)
// Animated with low-res canvas.  Saves 1 char, but looks real bad
r=Math.random;p=(X,Y,S,D,k)=>D&&(x.globalAlpha=.01,x.fillRect(X,Y,S,S),k=_=>p(X+2*S*r()-S,Y+S*r()/2,S*.8,D-1),k(),k());c.width=200;p(99,0,60,15)
// We can put the boxes underneath, but this looks worse
r=Math.random;p=(X,Y,S,D,k)=>D&&(x.globalAlpha=.01,x.fillRect(X,Y,S,S),k=_=>p(X+2*S*r()-S,Y-S*r()/2,S*.8,D-1),k(),k());t||p(900,900,500,15)
// Experiment, in a module we can reduce p=()=>{} into p(){} but it costs more to call it!
r=Math.random;m={p(X,Y,S,D,k){D&&(x.globalAlpha=.01,x.fillRect(X,Y,S,S),k=_=>m.p(X+2*S*r()-S,Y+S*r()/2,S*.8,D-1),k(),k())}};t||m.p(900,0,500,15)

// --- Trying to minimise the release ---
r=Math.random;p=(X,Y,S,D,i)=>{x.fillRect(X,Y,S,S);if(D)for(i=2;i--;x.globalAlpha=.01)p(X+2*S*r()-S,Y+S*r()/2,S*.8,D-1)};t||p(900,0,500,18)

// nystrand worked out how to minimize it, and animate it!  https://www.dwitter.net/d/2737
c.width|=p=(X,Y=X,S=X,D=16,r=_=>C(t+=S*D+t/8e6),k=_=>p(X+S*r(),Y+S*r()/3,S*.8,D-1))=>D&&x.fillRect(X,Y,S,S,x.globalAlpha=.01)&k()&k();p(580)
// nystrand with blue!  https://www.dwitter.net/d/2738
c.width|=p=(X,Y=X,S=X,D=15,r=_=>C(t+=S++),k=_=>p(X+S*r(),Y+S*r()/3,S*.8,D-1))=>D&&x.fillRect(X,Y,S,S,x.fillStyle=R(k(),k(),S*D,.01));p(580)
// If we use his random generator from the second, in the first, we get down to 134!
c.width|=p=(X,Y=X,S=X,D=16,r=_=>C(t+=S++),k=_=>p(X+S*r(),Y+S*r()/3,S*.8,D-1))=>D&&x.fillRect(X,Y,S,S,x.globalAlpha=.01)&k()&k();p(580)

// Me going back to circles for no particular reason
c.width|=p=(X,Y=X,S=X,D=12,r=_=>C(t+=S++),k=_=>p(X+S*r(),Y+S*r()/3,S*.8,D-1))=>D&&x.beginPath()&x.arc(X,Y,S,x.globalAlpha=.01,7)&k(x.fill())&k();p(580)

// Golfing my cloud with nystrand's tricks
r=Math.random;p=(X,Y,S,D,k)=>D&&(x.globalAlpha=.01,x.fillRect(X,Y,S,S),k=_=>p(X+2*S*r()-S,Y+S*r()/2,S*.8,D-1),k(),k());c.width|=0;p(900,0,500,15)
r=Math.random;p=(X=900,Y=0,S=500,D=15,k=_=>p(X+2*S*r()-S,Y+S*r()/2,S*.8,D-1))=>D&&(x.globalAlpha=.01,x.fillRect(X,Y,S,S),k(k()));c.width|=0;p()
r=Math.random;p=(X=900,Y=0,S=500,D=15,k=_=>p(X+2*S*r()-S,Y+S*r()/2,S*.8,D-1))=>D&&k(k(x.globalAlpha=.01,x.fillRect(X,Y,S,S)));c.width|=0;p()
r=Math.random;p=(X=900,Y=0,S=500,D=15,k=_=>p(X+2*S*r()-S,Y+S*r()/2,S*.8,D-1))=>D&&x.fillRect(X,Y,S,S,k(k(x.globalAlpha=.01)));c.width|=0;p()
r=Math.random;p=(X=900,Y=0,S=500,D=20,k=_=>p(X+2*S*r()-S,Y+S*r()/2,S*.8,D-1))=>D&&x.fillRect(X,Y,S,S,k(k(x.globalAlpha=.01)));c.width|=0;p()
// --- happy --- Framerate is very heavy; better not do two cloud dweets on the same page!
r=Math.random;p=(X,Y,S,D,k=_=>p(X+2*S*r()-S,Y+S*r()/2,S*.8,D-1))=>D&&x.fillRect(X,Y,S,S,k(k(x.globalAlpha=.01)));c.width|=0;p(900,0,500,20)
// Depth lower than 17 is a bit too fast for my Linux.  20 is ok.  21 takes far too long, and also crashed my browser!  So 20 it is.  Check first how it looks on Mac.  We may need to add t%2<.1 for future proofing, to force a 2-second gap between clouds
// TODO: t&1 might be a better way to limit than %
// We can use Y=X to get rain
r=Math.random;p=(S,D,X=950,Y=X,k=_=>p(S*.8,D-1,X+2*S*r()-S,Y-S*r()/2))=>D&&x.fillRect(X,Y,S,S,k(k(x.globalAlpha=.01)));c.width|=0;p(500,20)
// c.width|=undefined or c.width|=function
r=Math.random;c.width|=p=(S,D,X=950,Y=X,k=_=>p(S*.8,D-1,X+2*S*r()-S,Y-S*r()/2))=>D&&x.fillRect(X,Y,S,S,k(k(x.globalAlpha=.01)));p(500,16)
// --- possible release? --- "Rain cloud slideshow"
c.width|=p=(S,D=20,X=2*S,Y=X,k=_=>p(S*.79,D-1,X+2*S*r()-S,Y-S*r()/2))=>D&&x.fillRect(X,Y,S,S,k(k(x.globalAlpha=.01)));t?p(500):r=Math.random
r=Math.random;c.width|=p=(S,D,X=950,Y=X,k=_=>p(S*.8,D-1,X+2*S*r()-S,Y-S*r()/2))=>D&&x.fillRect(X,Y,S,S,k(k(x.globalAlpha=.01)));p(500,20)
// Slightly fluffier with .79 and darker with .15  Also moved the D=20 into the defaults, for free
r=Math.random;c.width|=p=(S,D=20,X=950,Y=X,k=_=>p(S*.79,D-1,X+2*S*r()-S,Y-S*r()/2))=>D&&x.fillRect(X,Y,S,S,k(k(x.globalAlpha=.015)));p(500)
// Or more spread out
r=Math.random;c.width|=p=(S,D=20,X=950,Y=X,k=_=>p(S*.8,D-1,X+2.2*S*r()-S,Y-S*r()/2))=>D&&x.fillRect(X,Y,S,S,k(k(x.globalAlpha=.01)));p(400)
// Skipping the first frame
r=Math.random;c.width|=p=(S,D=20,X=2*S,Y=X,k=_=>p(S*.8,D-1,X+2*S*r()-S,Y-S*r()/2))=>D&&x.fillRect(X,Y,S,S,k(k(x.globalAlpha=.02)));t&&p(500)
// Shaving off 1 char
c.width|=p=(S,D=20,X=2*S,Y=X,k=_=>p(S*.8,D-1,X+2*S*r()-S,Y-S*r()/2))=>D&&x.fillRect(X,Y,S,S,k(k(x.globalAlpha=.02)));t?p(500):r=Math.random
// --- RELEASED --- /2768 I prefer a lighter fluffier cloud
c.width|=p=(S,D=20,X=2*S,Y=X,k=_=>p(S*.79,D-1,X+2*S*r()-S,Y-S*r()/2))=>D&&x.fillRect(X,Y,S,S,k(k(x.globalAlpha=.01)));t?p(500):r=Math.random
// LOL what a place to define r !  Oh, this doesn't work, r is undefined
c.width|=p=(S,D,X=950,Y=X,k=_=>p(S*.8,D-1,X+2*S*r(r=Math.random)-S,Y-S*r()/2))=>D&&x.fillRect(X,Y,S,S,k(k(x.globalAlpha=.01)));p(500,16)
// This is no good because it always clears the canvas
c.width|=p=(S,D,X=950,Y=X,k=_=>p(S*.8,D-1,X+2*S*r(r=Math.random)-S,Y-S*r()/2))=>D&&x.fillRect(X,Y,S,S,k(k(x.globalAlpha=.01)));t&1&&p(500,16)
// This is no good because when D is low, it doesn't clear the canvas when it should!
t&1?p(500,16):c.width|=p=(S,D,X=950,Y=X,k=_=>p(S*.8,D-1,X+2*S*r(r=Math.random)-S,Y-S*r()/2))=>D&&x.fillRect(X,Y,S,S,k(k(x.globalAlpha=.01)))
t&1&&c.width|=(p=(S,D,X=950,Y=X,k=_=>p(S*.8,D-1,X+2*S*r(r=Math.random)-S,Y-S*r()/2))=>D&&x.fillRect(X,Y,S,S,k(k(x.globalAlpha=.01))))(500,16)
// This is probably ok (?) but needs 1 char in order to fit
t&1?c.width|=p=(S,D,X=950,Y=X,k=_=>p(S*.8,D-1,X+2*S*r()-S,Y-S*r()/2))=>D&&x.fillRect(X,Y,S,S,k(k(x.globalAlpha=.01)))&p(500,20):r=Math.random

// White clouds on blue sky:
c.width|=0;x.globalAlpha=1;x.fillStyle='#9cf';x.fillRect(0,0,1920,1180)
p=(S,D=20,X=2*S,Y=X,k=_=>p(S*.79,D-1,X+2*S*r()-S,Y-S*r()/2))=>D&&x.fillRect(X,Y,S,S,k(k(x.globalAlpha=.03,x.fillStyle='white')));t?p(500):r=Math.random
// Without the rain, and lower D
c.width|=0;x.globalAlpha=1;x.fillStyle='#9cf';x.fillRect(0,0,1920,1180)
p=(S,D,X,Y,k=_=>p(S*.79,D-1,X+2*S*r()-S,Y-S*r()/2+S/4))=>D&&x.fillRect(X,Y,S,S,k(k(x.globalAlpha=.04,x.fillStyle='white')));t?p(500,18,999,500):r=Math.random
// Actually we do still tend to get boxes below the cloud, simply because the boxes draw from their top-left, not their centers.

// Tricks to learn from nystrand's version:
/*
Default args can be used to avoid passing args.  The advantages are:

- It is costless to move an argument from a call into the function arg defaults (removing a `,` and adding a `=`).  And it is neccessary if you want to skip passing earlier args.
- If you want two args to start with the same value, you can make one copy from an earlier one.  (E.g. `S=X` above.)  This is cheaper than passing the same value twice, if the value is 3 or more chars.

    f=(x,y,k)=>bar;f(100,100,5)
    // becomes
    f=(x=100,y=x,k=5)=>bar;f()

- If you need temporary variables inside your function, you can initialise them in the args, which may help you to reduce the function body to one expression, hence avoiding the `{...}`s.  It also gives you a free closure around that arg, rather than assigning a global variable which might mess up recursion.

Bitwise operations will use undefined and NaN as if they were 0.  So if you need to do a bitwise operation, and you also happen to have a function definition (which get coerced to NaN) or the undefined result of a function call, you may use that instead of 0.  This can save two chars: the `0` and also the separator.

One of the most common places we use a bitwise operation on Dwitter is to clear the canvas: `c.width|=0`

    c.width|=0;foo()
    // becomes
    c.width|=foo()

or

	c.width|=0;r=()=>x
	// becomes
	c.width|=r=()=>x

Need a lot of semi-random numbers from -1 to 1?
Try this: `R=C(t++)`
If you want the numbers to change only slowly, consider something like: `R=C(t+=S++)`
`t` is your seed, which gets slighly changed each frame.
`S` is a value that should change during your iterator, but always the same way.  (It should not be dependent on earlier R.)

We can use & as a separator:

    D&&(a,b,c)
    // becomes
    D&&a&b&c

*/

// 2018
// We can remove 7 chars from the cloud gallery, by using S>7 and forgetting D entirely
c.width|=p=(S,X=2*S,Y=X,k=_=>p(S*.79,X+2*S*r()-S,Y-S*r()/2))=>S>9&&x.fillRect(X,Y,S,S,k(k(x.globalAlpha=.01)));t?p(500):r=Math.random
